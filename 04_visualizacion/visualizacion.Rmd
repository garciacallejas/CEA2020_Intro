---
title: "Visualización de datos con ggplot2"
author: "David García Callejas"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, results = FALSE, warning = FALSE, message = FALSE)
```

En esta sesión veremos cómo realizar diferentes tipos de gráficos en R, y algunas opciones de personalización de las más usadas. Usaremos el paquete `ggplot2`, que es seguramente el más usado hoy día para producir gráficos de calidad. R tiene otros paquetes y funciones para generar gráficos, pero `ggplot2` es intuitivo, fácilmente editable, y tiene una documentación muy buena. El acrónimo `ggplot2` viene de "grammar of graphics plots", por el hecho de que este conjunto de funciones esta basado en la llamada "Grammar of Graphics", una sintaxis que estructura la creación de gráficos a partir de capas con diferente información. 

Como primer ejemplo, vamos a crear un gráfico de puntos, el mismo que usamos para la sesión sobre modelos de regresión lineal

```{r}
# este paquete incluye ggplot2
library(tidyverse)

# leemos los datos de personajes de Star Wars
personajes_SW <- read.csv2(file = "../data/starwars_info_personajes.csv",stringsAsFactors = FALSE)

# queremos crear una figura que muestre la altura y el peso de cada personaje, 
# donde cada personaje sea un punto

# lo primero que tenemos que entender es que un "plot", una figura, también la podemos guardar en una variable.
# Para crear una figura nueva, usamos la función ggplot
# en esta función, tenemos que especificar qué datos queremos usar para la figura

figura1 <- ggplot(data = personajes_SW)

# ¿qué contenido tiene este objeto? 
figura1 # en Rstudio, aparecerá la zona de "plots" en blanco.
class(figura1) # este objeto es de clase ggplot

# a partir de aquí, podemos ir añadiendo "capas" de información a nuestra figura vacía
# lo primero que debemos pensar en incluir son los ejes de nuestra figura.
# Esto se puede hacer también en la función ggplot

# el argumento "aes" significa "aesthetics", es decir, la estética, los detalles de la figura.
figura1 <- ggplot(data = personajes_SW,aes(x = height, y = mass))
figura1

# ahora deberíamos ver los ejes sobre los que queremos dibujar nuestros puntos.
# Estos puntos, uno por cada personaje, serán una capa nueva de información.
# Las capas se añaden en ggplot2 con las funciones "geom_", 
# literalmente añadiendo elementos al objeto que hemos creado
figura1 <- figura1 + geom_point()
figura1
```

Con esto ya tenemos nuestro primer gráfico con ggplot2. Podemos guardar cualquier gráfico que creemos de diferentes maneras. Por ejemplo, Rstudio nos permite exportar cualquier gráfico que aparezca en la pestaña "Plots", usando el botón "Export". Sin embargo, es más recomendable usar la función `ggsave` del propio paquete ggplot2, que da más control y automatización. 

```{r eval=FALSE}
# ggsave por defecto usa pulgadas como unidades...
# yo suelo ir haciendo ensayo-error con diferentes tamaños 
# hasta encontrar el balance adecuado entre tamaño de letra/puntos, y fondo
ggsave(filename = "mi_figura.png",plot = figura1,width = 5,height = 5)
```

Antes de ver otros tipos de figuras, veremos cómo retocar esta figura inicial. Una primera mejora puede ser colorear cada punto según su especie.

```{r}
# lo primero que haremos es, como antes, eliminar a Jabba, que nos descuadra toda la imagen.
sw2 <- subset(personajes_SW, name != "Jabba Desilijic Tiure")

# y creamos una figura en la que cada especie tenga un color diferente
# para esto añadimos un "aesthetic" más, pero dentro de la función que dibuja los puntos.
figura2 <- ggplot(sw2, aes(x = height, y = mass)) +
  geom_point(aes(color = species))
  
# la figura funciona, pero hay muchas, demasiadas especies como para que sea efectiva.
# podemos agrupar las especies en grupos más grandes, para simplificar. 
# ¿Cuántos personajes hay de cada especie?
table(sw2$species)

# de casi todas las especies hay un solo individuo. Dejaremos los droides, los humanos,
# y, por curiosidad, a Yoda. El resto los agruparemos en una categoría "otros"
# primero, creamos una columna idéntica a "species"
sw2$species_group <- sw2$species
# y agrupamos aquellas que no son ni "Human", ni "Droid", ni "Yoda's species"
sw2$species_group[which(!sw2$species %in% c("Human", "Droid", "Yoda's species"))] <- "Other"
table(sw2$species_group)

# rehacemos nuestra figura con la nueva clasificación
figura2 <- ggplot(sw2, aes(x = height, y = mass)) +
  geom_point(aes(color = species_group))
```

Al crear la figura, ggplot elimina automaticamente los datos que sean NA. Al lanzar el código en vuestro ordenador, habréis visto un "warning" avisando de que hay 28 filas con NA. Antes de continuar explorando otras opciones para retocar la leyenda, las etiquetas, títulos, ejes, etc, veremos otros tipos de figuras que podemos crear.

```{r}
# gráfico de barras: cuántos individuos hay por cada grupo de especies.
# Para esta figura no necesitamos añadir eje y, porque este será el conteo de cada grupo.
# el conteo se calcula con geom_bar, añadiendo el argumento "stat = "count""
figura3 <- ggplot(sw2, aes(x = species_group)) +
  geom_bar(stat="count")

# como antes, podemos colorear cada grupo. Para colorear areas, usamos la orden "fill",
# que significa, literalmente, "relleno".
figura3 <- ggplot(sw2, aes(x = species_group)) +
  geom_bar(stat="count", aes(fill = species_group))

# gráfico de cajas (boxplot)
figura4 <- ggplot(sw2, aes(x = species_group, y = height)) + 
  geom_boxplot(aes(fill = species_group))

```

Para hacer gráficos de líneas usamos los datos de terremotos. Vamos a dibujar el número de terremotos por siglo. Este ejemplo es un poco más complejo por la preparación previa que hacemos de los datos.

```{r}
eq <- read.csv2(file = "../data/Earthquake_data.csv",dec = ".",stringsAsFactors = FALSE)

# necesitamos crear una columna "century"
# en principio vacía
eq$century <- NA

# hay varias maneras de traducir el año a siglo. 
# Por lo que hemos visto hasta ahora, podemos hacerlo con un bucle, que vaya fila por fila,
# calcule a qué siglo corresponde el año, 
# y rellene el valor de cada terremoto.

for(i in 1:nrow(eq)){
  
  my.century <- NA
  
  if(eq$Year[i] < 1500){
    my.century <- "< XVI"
  }else if(eq$Year[i] >= 1500 & eq$Year[i] < 1600){
    my.century <- "XVI"
  }else if(eq$Year[i] >= 1600 & eq$Year[i] < 1700){
    my.century <- "XVII"
  }else if(eq$Year[i] >= 1700 & eq$Year[i] < 1800){
    my.century <- "XVIII"
  }else if(eq$Year[i] >= 1800 & eq$Year[i] < 1900){
    my.century <- "XIX"
  }else if(eq$Year[i] >= 1900){
    my.century <- "XX"
  }
  
  eq$century[i] <- my.century
  
}

table(eq$century)

# lo más claro es crear un segundo dataframe sólo con esta información
terremotos_siglo <- data.frame(terremotos = table(eq$century))
# al usar el resultado de "table" para crear un dataframe, generamos dos columnas, 
# una con el nombre del siglo y otra con el número de terremotos
terremotos_siglo
# los nombres del dataframe no son del todo correctos
names(terremotos_siglo) <- c("siglo","terremotos")
# y el orden no es adecuado, no debería ser alfabético. En este caso, necesitamos un factor
terremotos_siglo$siglo <- factor(terremotos_siglo$siglo, levels = c("< XVI", "XVI", "XVII", "XVIII", "XIX", "XX"))
```

Una vez tenemos los datos agrupados como nos interesa, creamos la figura

```{r}
# a veces, R tiene comportamientos extraños. Si no entendéis porqué hace falta "group = 1",
# no os preocupéis... yo tampoco.
# En el "cookbook" (enlace abajo), dice: 
# For line graphs, the data points must be grouped so that it knows which points to connect. 
# In this case, it is simple – all points should be connected, so group=1.
eq.plot <- ggplot(terremotos_siglo, aes(x = siglo, y = terremotos, group = 1)) +
  geom_line()
```


Otros recursos sobre `ggplot2`:

* Trucos útiles y sencillos: http://www.cookbook-r.com/Graphs/

* El libro escrito por Hadley Wickham, el creador del paquete: https://ggplot2-book.org/

